"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/cases/memoryIntro",{

/***/ "./pages/cases/memory/index.tsx":
/*!**************************************!*\
  !*** ./pages/cases/memory/index.tsx ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ GameGenerator; }\n/* harmony export */ });\n/* harmony import */ var _Users_faurskov_Documents_projekter_undervisning_next_nextjs_blog_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/toConsumableArray */ \"./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\");\n/* harmony import */ var _Users_faurskov_Documents_projekter_undervisning_next_nextjs_blog_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/slicedToArray */ \"./node_modules/@babel/runtime/helpers/esm/slicedToArray.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_3__);\n/* module decorator */ module = __webpack_require__.hmd(module);\n\n\n\nvar _jsxFileName = \"/Users/faurskov/Documents/projekter/undervisning/next/nextjs-blog/pages/cases/memory/index.tsx\",\n    _this = undefined,\n    _s = $RefreshSig$(),\n    _s2 = $RefreshSig$();\n\n //import './index.css';\n\n/**\n * GameGenerator\n * - GameSession\n * - - Cell\n * - Footer\n * \n/* \n  Denne konstant simulerer ENUM - består af et sæt navngivne værdier kaldet elementer\n  Jeg bruger ENUM for at undgå stavefejl\n*/\n\n\n\nvar GameStatus = {\n  // Før Start-knappen markeres\n  NEW: 'NEW',\n  // Når de celler som skal markeres vises i starten\n  CHALLENGE: 'CHALLENGE',\n  // Selve spillet - aktiveres efter nogle få sekunder\n  PLAYING: 'PLAYING',\n  // Alle celler fundet\n  WON: 'WON',\n  // Tiden er gået eller brugeren har brugt for mange forsøg\n  LOST: 'LOST'\n}; // Disse farver kan udskiftes med hexamaltal - eks.: #FFFFFF\n\nvar CellStatus = {\n  NORMAL: 'white',\n  // Cellen er ikke markeret\n  HIGHLIGHT: 'lightblue',\n  // GameStatus er CHALLENGE og cellen er en Challenge-cell\n  CORRECT: 'lightgreen',\n  // Når brugeren har valgt en celle og cellen er en Challenge-cell\n  WRONG: 'pink' // Når brugeren har valgt en celle, og cellen ikke er en Challenge-cell\n\n};\n/* Beskeder som brugeren får i spillets forskellige faser\n    NEW:         Spillet er netop sat igang (enten via timer eller via knappen)\n    CHALLENGE:   Der går få sekunder hvor brugeren ser de celler hun skal huske\n    PLAYING:     Spillet er igang, og brugeren skal huske hvor challenge-cellerne er (alle hvide)\n    WON:         Brugeren har fundet alle Challenge-cellerne indenfor tiden, og uden for mange forsøg\n    LOST:        Tiden er gået eller brugeren har brugt for mange forsøg\n*/\n\nvar Messages = {\n  NEW: 'You will have a few seconds to memorize the blue random cells',\n  CHALLENGE: 'Remember these blue cells now',\n  PLAYING: 'Which cells were blue?',\n  WON: 'Victory!',\n  LOST: 'Game Over'\n}; // Messages[gameStatus] - sådan får jeg den rette besked i Footer\n\nvar Cell = function Cell(_ref) {\n  var width = _ref.width,\n      gameStatus = _ref.gameStatus,\n      isChallenge = _ref.isChallenge,\n      isPicked = _ref.isPicked,\n      onClick = _ref.onClick;\n  var cellStatus = CellStatus.NORMAL; // Der skal kun ske noget, hvis GameStatus ikke er NEW\n\n  if (gameStatus !== GameStatus.NEW) {\n    if (isPicked) {\n      // Gamestatus er ikke NEW og cellen er valgt\n      // Der testes om cellen er en challenge-cell - returneres CORRECT/WRONG\n      cellStatus = isChallenge ? CellStatus.CORRECT : CellStatus.WRONG;\n    } else if (isChallenge && (gameStatus === GameStatus.CHALLENGE || gameStatus === GameStatus.LOST)) {\n      /*\n        Cellen 'highlightes' hvis cellen er en Challenge-cell, \n        og GameStatus enten er:\n        - CHALLENGE \n          eller \n        - LOST\n      */\n      cellStatus = CellStatus.HIGHLIGHT;\n    }\n  }\n\n  return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxDEV)(\"div\", {\n    className: \"cell\",\n    style: {\n      width: \"\".concat(width, \"%\"),\n      backgroundColor: cellStatus\n    },\n    onClick: onClick\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 89,\n    columnNumber: 5\n  }, _this);\n};\n\n_c = Cell;\n\nvar Footer = function Footer(_ref2) {\n  var gameStatus = _ref2.gameStatus,\n      countdown = _ref2.countdown,\n      startGame = _ref2.startGame,\n      resetGame = _ref2.resetGame;\n\n  var buttonAreaContent = function buttonAreaContent() {\n    switch (gameStatus) {\n      case GameStatus.NEW:\n        return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxDEV)(\"button\", {\n          onClick: startGame,\n          children: \"Start Game\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 112,\n          columnNumber: 16\n        }, _this);\n\n      case GameStatus.CHALLENGE:\n        console.log(\"CHALLENGE\"); // falls through\n\n        return \"CHALLENGE\";\n\n      case GameStatus.PLAYING:\n        return countdown + \" secounds\";\n      // case GameStatus.WON:\n      //   console.log(\"WIN\");\n      // falls through\n\n      case GameStatus.LOST:\n        return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxDEV)(\"button\", {\n          onClick: resetGame,\n          children: \"Play Again\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 123,\n          columnNumber: 16\n        }, _this);\n\n      default:\n        console.log(\"default\");\n        return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxDEV)(\"button\", {\n          onClick: resetGame,\n          children: \"Play Again\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 126,\n          columnNumber: 18\n        }, _this);\n        ;\n    }\n  };\n\n  return (\n    /*#__PURE__*/\n    // React.Fragment <>\n    (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_3__.Fragment, {\n      children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxDEV)(\"div\", {\n        className: \"message\",\n        children: Messages[gameStatus]\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 132,\n        columnNumber: 7\n      }, _this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxDEV)(\"div\", {\n        className: \"button\",\n        children: buttonAreaContent()\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 136,\n        columnNumber: 7\n      }, _this)]\n    }, void 0, true)\n  );\n};\n\n_c2 = Footer;\n\nvar GameSession = function GameSession(_ref3) {\n  _s();\n\n  var cellIds = _ref3.cellIds,\n      challengeCellIds = _ref3.challengeCellIds,\n      cellWidth = _ref3.cellWidth,\n      challengeSize = _ref3.challengeSize,\n      challengeSeconds = _ref3.challengeSeconds,\n      playSeconds = _ref3.playSeconds,\n      maxWrongAttempts = _ref3.maxWrongAttempts,\n      autoStart = _ref3.autoStart,\n      resetGame = _ref3.resetGame;\n\n  // useState(GameStatus.PLAYING);\n  // useState(GameStatus.WON);\n  // useState(GameStatus.LOST);\n  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(autoStart ? GameStatus.CHALLENGE : GameStatus.NEW),\n      gameStatus = _useState[0],\n      setGameStatus = _useState[1]; // pickedCellIds holder styr på hvilke celler som brugeren har valgt\n  // useState([0, 1, 2, 22, 23, 24]);\n\n\n  var tmpPickedCellIds = [];\n\n  var _useState2 = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(tmpPickedCellIds),\n      pickedCellIds = _useState2[0],\n      setPickedCellIds = _useState2[1]; // countdown holder styr på hvor mange sekunder brugeren har tilbage - starter med playSeconds prop\n\n\n  var _useState3 = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(playSeconds),\n      countdown = _useState3[0],\n      setCountdown = _useState3[1];\n\n  (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(function () {\n    // Brugeren har startet spillet, og kan i tre sekunder se hvor de farvede celler er placeret\n    var timerId;\n\n    if (gameStatus === GameStatus.CHALLENGE) {\n      timerId = setTimeout(function () {\n        return setGameStatus(GameStatus.PLAYING);\n      }, 1000 * challengeSeconds);\n    } // Spillet er i gang, og brugeren har 10 sekunder til at markere de rigtige celler\n\n\n    if (gameStatus === GameStatus.PLAYING) {\n      timerId = setInterval(function () {\n        setCountdown(function (countdown) {\n          if (countdown === 1) {\n            clearTimeout(timerId);\n            setGameStatus(GameStatus.LOST);\n          }\n\n          return countdown - 1;\n        });\n      }, 1000);\n    }\n\n    if (gameStatus === GameStatus.LOST) {\n      console.log(\"Klar til næste spil!\"); // setGameStatus(GameStatus.CHALLENGE);\n    }\n\n    return function () {\n      return clearTimeout(timerId);\n    };\n  }, [challengeSeconds, gameStatus]);\n  (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(function () {\n    var _utils$arrayCrossCoun = utils.arrayCrossCounts(pickedCellIds, challengeCellIds),\n        _utils$arrayCrossCoun2 = (0,_Users_faurskov_Documents_projekter_undervisning_next_nextjs_blog_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_1__.default)(_utils$arrayCrossCoun, 2),\n        correctPicks = _utils$arrayCrossCoun2[0],\n        wrongPicks = _utils$arrayCrossCoun2[1];\n\n    if (correctPicks === challengeSize) {\n      setGameStatus(GameStatus.WON);\n    }\n\n    if (wrongPicks === maxWrongAttempts) {\n      setGameStatus(GameStatus.LOST);\n    }\n  }, [challengeCellIds, challengeSize, maxWrongAttempts, pickedCellIds]);\n  /*\n    - Alle variabler brugt i useEffect() bør inkluderes i ovenstående array, som holder øje med, \n    hvornår useEffect skal opdateres. \n    - jslint holder øje med, om alle relevante variabler er med.\n  */\n\n  var pickCell = function pickCell(cellId) {\n    if (gameStatus === GameStatus.PLAYING) {\n      setPickedCellIds(function (pickedCellIds) {\n        if (pickedCellIds.includes(cellId)) {\n          return pickedCellIds;\n        }\n\n        return [].concat((0,_Users_faurskov_Documents_projekter_undervisning_next_nextjs_blog_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__.default)(pickedCellIds), [cellId]);\n      });\n    }\n  };\n\n  return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxDEV)(\"div\", {\n    className: \"game\",\n    children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxDEV)(\"div\", {\n      className: \"grid\",\n      children: cellIds.map(function (cellId) {\n        return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxDEV)(Cell // unikt ID til hver celle\n        , {\n          // Bredde som afhænger af antal celler i hver række\n          width: cellWidth // Status på spillet \n          ,\n          gameStatus: gameStatus // Er det en challenge cell?  - bruger Array.includes\n          ,\n          isChallenge: challengeCellIds.includes(cellId) // er cellen valgt?           - bruger Array.includes\n          ,\n          isPicked: pickedCellIds.includes(cellId) // Nedarver funktion som tjekker om cellen allerede er valgt - ellers inkluderes den i valgte celler (pickedCellIds)\n          ,\n          onClick: function onClick() {\n            return pickCell(cellId);\n          }\n        }, cellId, false, {\n          fileName: _jsxFileName,\n          lineNumber: 235,\n          columnNumber: 11\n        }, _this);\n      })\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 233,\n      columnNumber: 7\n    }, _this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxDEV)(Footer, {\n      gameStatus: gameStatus,\n      countdown: countdown,\n      startGame: function startGame() {\n        return setGameStatus(GameStatus.CHALLENGE);\n      },\n      resetGame: resetGame\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 251,\n      columnNumber: 7\n    }, _this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 232,\n    columnNumber: 5\n  }, _this);\n};\n\n_s(GameSession, \"fxA85YgQC6gu6CN39eEEdWcquSM=\");\n\n_c3 = GameSession;\nfunction GameGenerator() {\n  _s2();\n\n  // Placer altid state-elements først!\n  var _useState4 = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(1),\n      gameId = _useState4[0],\n      setGameId = _useState4[1];\n\n  var gridSize = 5;\n  var challengeSize = 6; // Returnerer en array med x-antal elemter 1,2,3...\n  // Fixed Array for hver enkelt spil (skal derfor ikke være i state)\n\n  var cellIds = utils.createArray(gridSize * gridSize);\n  var cellWidth = 100 / gridSize;\n  /*\n    Returnerer en array med tilfældige tal\n    - cellIds er en array med de aktuelle felter\n    - challengeSize bestemmer hvor mange farver, brugeren skal finde\n  */\n\n  var challengeCellIds = utils.sampleArray(cellIds, challengeSize);\n  return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxDEV)(GameSession, {\n    challengeSize: challengeSize,\n    cellIds: cellIds,\n    cellWidth: cellWidth,\n    challengeCellIds: challengeCellIds,\n    challengeSeconds: 3,\n    playSeconds: 10,\n    maxWrongAttempts: 3,\n    autoStart: gameId > 1,\n    resetGame: function resetGame() {\n      return setGameId(function (gameId) {\n        return gameId + 1;\n      });\n    }\n  }, gameId, false, {\n    fileName: _jsxFileName,\n    lineNumber: 280,\n    columnNumber: 5\n  }, this);\n}\n\n_s2(GameGenerator, \"NdxBUEh67UKnEQOsYqMda/Noysc=\");\n\n_c4 = GameGenerator;\n; // Math science\n\nvar utils = {\n  /* Create an array based on a numeric size property.\n     Example: createArray(5) => [0, 1, 2, 3, 4] */\n  createArray: function createArray(size) {\n    return Array.from({\n      length: size\n    }, function (_, i) {\n      return i;\n    });\n  },\n\n  /* Pick random elements from origArray up to sampleSize\n     And use them to form a new array.\n     Example: sampleArray([9, 12, 4, 7, 5], 3) => [12, 7, 5] */\n  sampleArray: function sampleArray(origArray, sampleSize) {\n    var copy = origArray.slice(0);\n    var sample = [];\n\n    for (var i = 0; i < sampleSize && i < copy.length; i++) {\n      var index = Math.floor(Math.random() * copy.length);\n      sample.push(copy.splice(index, 1)[0]);\n    }\n\n    return sample;\n  },\n\n  /* Given a srcArray and a crossArray, count how many elements \n     in srcArray exist or do not exist in crossArray.\n     Returns an array like [includeCount, excludeCount]\n     Example: arrayCrossCounts([0, 1, 2, 3, 4], [1, 3, 5]) => [2, 3] */\n  arrayCrossCounts: function arrayCrossCounts(srcArray, crossArray) {\n    var includeCount = 0;\n    var excludeCount = 0;\n\n    srcLoop: for (var s = 0; s < srcArray.length; s++) {\n      for (var c = 0; c < crossArray.length; c++) {\n        if (crossArray[c] === srcArray[s]) {\n          includeCount += 1;\n          continue srcLoop;\n        }\n      }\n\n      excludeCount += 1;\n    }\n\n    return [includeCount, excludeCount];\n  }\n}; // ReactDOM.render(\n//   <GameGenerator />,\n//   document.getElementById('root')\n// );\n\nvar _c, _c2, _c3, _c4;\n\n$RefreshReg$(_c, \"Cell\");\n$RefreshReg$(_c2, \"Footer\");\n$RefreshReg$(_c3, \"GameSession\");\n$RefreshReg$(_c4, \"GameGenerator\");\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFBLFlBQVksSUFBSSxDQUFoQjtBQUNEOztBQUNELFdBQU8sQ0FBQ0QsWUFBRCxFQUFlQyxZQUFmLENBQVA7QUFDRDtBQW5DVyxDQUFkLEVBc0NBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3BhZ2VzL2Nhc2VzL21lbW9yeS9pbmRleC50c3g/NTgwZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuLy9pbXBvcnQgJy4vaW5kZXguY3NzJztcbi8qKlxuICogR2FtZUdlbmVyYXRvclxuICogLSBHYW1lU2Vzc2lvblxuICogLSAtIENlbGxcbiAqIC0gRm9vdGVyXG4gKiBcbi8qIFxuICBEZW5uZSBrb25zdGFudCBzaW11bGVyZXIgRU5VTSAtIGJlc3TDpXIgYWYgZXQgc8OmdCBuYXZuZ2l2bmUgdsOmcmRpZXIga2FsZGV0IGVsZW1lbnRlclxuICBKZWcgYnJ1Z2VyIEVOVU0gZm9yIGF0IHVuZGfDpSBzdGF2ZWZlamxcbiovXG5cbmNvbnN0IEdhbWVTdGF0dXMgPSB7XG4gIC8vIEbDuHIgU3RhcnQta25hcHBlbiBtYXJrZXJlc1xuICBORVc6ICAgICAgICAnTkVXJyxcbiAgLy8gTsOlciBkZSBjZWxsZXIgc29tIHNrYWwgbWFya2VyZXMgdmlzZXMgaSBzdGFydGVuXG4gIENIQUxMRU5HRTogICdDSEFMTEVOR0UnLFxuICAvLyBTZWx2ZSBzcGlsbGV0IC0gYWt0aXZlcmVzIGVmdGVyIG5vZ2xlIGbDpSBzZWt1bmRlclxuICBQTEFZSU5HOiAgICAnUExBWUlORycsXG4gIC8vIEFsbGUgY2VsbGVyIGZ1bmRldFxuICBXT046ICAgICAgICAnV09OJyxcbiAgLy8gVGlkZW4gZXIgZ8OlZXQgZWxsZXIgYnJ1Z2VyZW4gaGFyIGJydWd0IGZvciBtYW5nZSBmb3Jzw7hnXG4gIExPU1Q6ICAgICAgICdMT1NUJyxcbn07XG4vLyBEaXNzZSBmYXJ2ZXIga2FuIHVkc2tpZnRlcyBtZWQgaGV4YW1hbHRhbCAtIGVrcy46ICNGRkZGRkZcbmNvbnN0IENlbGxTdGF0dXMgPSB7XG4gIE5PUk1BTDogICAgICd3aGl0ZScsICAgICAgLy8gQ2VsbGVuIGVyIGlra2UgbWFya2VyZXRcbiAgSElHSExJR0hUOiAgJ2xpZ2h0Ymx1ZScsICAvLyBHYW1lU3RhdHVzIGVyIENIQUxMRU5HRSBvZyBjZWxsZW4gZXIgZW4gQ2hhbGxlbmdlLWNlbGxcbiAgQ09SUkVDVDogICAgJ2xpZ2h0Z3JlZW4nLCAvLyBOw6VyIGJydWdlcmVuIGhhciB2YWxndCBlbiBjZWxsZSBvZyBjZWxsZW4gZXIgZW4gQ2hhbGxlbmdlLWNlbGxcbiAgV1JPTkc6ICAgICAgJ3BpbmsnLCAgICAgICAvLyBOw6VyIGJydWdlcmVuIGhhciB2YWxndCBlbiBjZWxsZSwgb2cgY2VsbGVuIGlra2UgZXIgZW4gQ2hhbGxlbmdlLWNlbGxcbn07XG4vKiBCZXNrZWRlciBzb20gYnJ1Z2VyZW4gZsOlciBpIHNwaWxsZXRzIGZvcnNrZWxsaWdlIGZhc2VyXG4gICAgTkVXOiAgICAgICAgIFNwaWxsZXQgZXIgbmV0b3Agc2F0IGlnYW5nIChlbnRlbiB2aWEgdGltZXIgZWxsZXIgdmlhIGtuYXBwZW4pXG4gICAgQ0hBTExFTkdFOiAgIERlciBnw6VyIGbDpSBzZWt1bmRlciBodm9yIGJydWdlcmVuIHNlciBkZSBjZWxsZXIgaHVuIHNrYWwgaHVza2VcbiAgICBQTEFZSU5HOiAgICAgU3BpbGxldCBlciBpZ2FuZywgb2cgYnJ1Z2VyZW4gc2thbCBodXNrZSBodm9yIGNoYWxsZW5nZS1jZWxsZXJuZSBlciAoYWxsZSBodmlkZSlcbiAgICBXT046ICAgICAgICAgQnJ1Z2VyZW4gaGFyIGZ1bmRldCBhbGxlIENoYWxsZW5nZS1jZWxsZXJuZSBpbmRlbmZvciB0aWRlbiwgb2cgdWRlbiBmb3IgbWFuZ2UgZm9yc8O4Z1xuICAgIExPU1Q6ICAgICAgICBUaWRlbiBlciBnw6VldCBlbGxlciBicnVnZXJlbiBoYXIgYnJ1Z3QgZm9yIG1hbmdlIGZvcnPDuGdcbiovXG5pbnRlcmZhY2UgTWVzc2FnZXNJe1xuICBORVc6c3RyaW5nLFxuICBDSEFMTEVOR0U6c3RyaW5nLFxuICBQTEFZSU5HOnN0cmluZyxcbiAgV09OOnN0cmluZyxcbiAgTE9TVDpzdHJpbmdcbn1cbmNvbnN0IE1lc3NhZ2VzOk1lc3NhZ2VzSSB8IGFueSA9IHtcbiAgTkVXOiAgICAgICAgJ1lvdSB3aWxsIGhhdmUgYSBmZXcgc2Vjb25kcyB0byBtZW1vcml6ZSB0aGUgYmx1ZSByYW5kb20gY2VsbHMnLFxuICBDSEFMTEVOR0U6ICAnUmVtZW1iZXIgdGhlc2UgYmx1ZSBjZWxscyBub3cnLFxuICBQTEFZSU5HOiAgICAnV2hpY2ggY2VsbHMgd2VyZSBibHVlPycsXG4gIFdPTjogICAgICAgICdWaWN0b3J5IScsXG4gIExPU1Q6ICAgICAgICdHYW1lIE92ZXInXG59O1xuLy8gTWVzc2FnZXNbZ2FtZVN0YXR1c10gLSBzw6VkYW4gZsOlciBqZWcgZGVuIHJldHRlIGJlc2tlZCBpIEZvb3RlclxuaW50ZXJmYWNlIENlbGxQcm9wc3tcbiAgd2lkdGggICAgICAgOm51bWJlcixcbiAgZ2FtZVN0YXR1cyAgOnN0cmluZyxcbiAgaXNDaGFsbGVuZ2UgOmJvb2xlYW4sXG4gIGlzUGlja2VkICAgIDpib29sZWFuLFxuICBvbkNsaWNrICAgICA6YW55XG59XG5jb25zdCBDZWxsID0gKHsgXG4gICAgd2lkdGgsICAgICAgICAgICAgLy8gQ2VsbGVucyBicmVkZGUgLSBhbnRhbCBicmVkZGUgZGVsdCBtZWQgYW50YWwgaG9yaXNvbnRhbGUgY2VsbGVyXG4gICAgZ2FtZVN0YXR1cywgICAgICAgLy8gRXIgc3BpbGxldCBpa2tlIE5FVywgc8OlIHRlc3RlcyBmb3Jzw7hnZXQgZm9yIENPUlJFQ1QgZWxlbHIgV1JPTkdcbiAgICBpc0NoYWxsZW5nZSwgICAgICAvLyBPbSBjZWxsZW4gYsO4ciB2w6ZsZ2VzIChDaGFsbGVuZ2UtY2VsbClcbiAgICBpc1BpY2tlZCwgICAgICAgICAvLyBPbSBjZWxsZW4gZXIgdmFsZ3RcbiAgICBvbkNsaWNrICAgICAgICAgICAvLyBOZWRhcnZldCBmdW5rdGlvblxuICB9OkNlbGxQcm9wc1xuICApID0+IHtcbiAgbGV0IGNlbGxTdGF0dXMgPSBDZWxsU3RhdHVzLk5PUk1BTDtcbiAgLy8gRGVyIHNrYWwga3VuIHNrZSBub2dldCwgaHZpcyBHYW1lU3RhdHVzIGlra2UgZXIgTkVXXG4gIGlmIChnYW1lU3RhdHVzICE9PSBHYW1lU3RhdHVzLk5FVykge1xuICAgIGlmIChpc1BpY2tlZCkge1xuICAgICAgLy8gR2FtZXN0YXR1cyBlciBpa2tlIE5FVyBvZyBjZWxsZW4gZXIgdmFsZ3RcbiAgICAgIC8vIERlciB0ZXN0ZXMgb20gY2VsbGVuIGVyIGVuIGNoYWxsZW5nZS1jZWxsIC0gcmV0dXJuZXJlcyBDT1JSRUNUL1dST05HXG4gICAgICBjZWxsU3RhdHVzID0gaXNDaGFsbGVuZ2UgPyBDZWxsU3RhdHVzLkNPUlJFQ1QgOiBDZWxsU3RhdHVzLldST05HO1xuICAgIH0gZWxzZSBpZiAoaXNDaGFsbGVuZ2UgJiYgKGdhbWVTdGF0dXMgPT09IEdhbWVTdGF0dXMuQ0hBTExFTkdFIHx8IGdhbWVTdGF0dXMgPT09IEdhbWVTdGF0dXMuTE9TVCkpIHtcbiAgICAgIC8qXG4gICAgICAgIENlbGxlbiAnaGlnaGxpZ2h0ZXMnIGh2aXMgY2VsbGVuIGVyIGVuIENoYWxsZW5nZS1jZWxsLCBcbiAgICAgICAgb2cgR2FtZVN0YXR1cyBlbnRlbiBlcjpcbiAgICAgICAgLSBDSEFMTEVOR0UgXG4gICAgICAgICAgZWxsZXIgXG4gICAgICAgIC0gTE9TVFxuICAgICAgKi9cbiAgICAgIGNlbGxTdGF0dXMgPSBDZWxsU3RhdHVzLkhJR0hMSUdIVDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICBjbGFzc05hbWUgPSBcImNlbGxcIlxuICAgICAgc3R5bGUgICAgID0ge3sgd2lkdGg6IGAke3dpZHRofSVgLCBiYWNrZ3JvdW5kQ29sb3I6IGNlbGxTdGF0dXMgfX1cbiAgICAgIG9uQ2xpY2sgICA9IHtvbkNsaWNrfVxuICAgIC8+XG4gICk7XG59O1xuXG5pbnRlcmZhY2UgRm9vdGVyUHJvcHN7XG4gIGdhbWVTdGF0dXM6c3RyaW5nLFxuICBjb3VudGRvd246bnVtYmVyLFxuICBzdGFydEdhbWU6IChldmVudDogUmVhY3QuTW91c2VFdmVudDxIVE1MQnV0dG9uRWxlbWVudD4pID0+IHZvaWRcbiAgcmVzZXRHYW1lOihldmVudDogUmVhY3QuTW91c2VFdmVudDxIVE1MQnV0dG9uRWxlbWVudD4pID0+IHZvaWRcbn1cbmNvbnN0IEZvb3RlciA9ICh7IFxuICBnYW1lU3RhdHVzLCBcbiAgY291bnRkb3duLCBcbiAgc3RhcnRHYW1lLCBcbiAgcmVzZXRHYW1lIFxufTpGb290ZXJQcm9wcykgPT4ge1xuICBjb25zdCBidXR0b25BcmVhQ29udGVudCA9ICgpID0+IHtcbiAgICBzd2l0Y2goZ2FtZVN0YXR1cykge1xuICAgICAgY2FzZSBHYW1lU3RhdHVzLk5FVzpcbiAgICAgICAgcmV0dXJuIDxidXR0b24gb25DbGljaz17c3RhcnRHYW1lfT5TdGFydCBHYW1lPC9idXR0b24+O1xuICAgICAgY2FzZSBHYW1lU3RhdHVzLkNIQUxMRU5HRTpcbiAgICAgICAgY29uc29sZS5sb2coXCJDSEFMTEVOR0VcIilcbiAgICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgICByZXR1cm4gXCJDSEFMTEVOR0VcIjtcbiAgICAgIGNhc2UgR2FtZVN0YXR1cy5QTEFZSU5HOlxuICAgICAgICByZXR1cm4gY291bnRkb3duK1wiIHNlY291bmRzXCI7XG4gICAgIC8vIGNhc2UgR2FtZVN0YXR1cy5XT046XG4gICAgIC8vICAgY29uc29sZS5sb2coXCJXSU5cIik7XG4gICAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgIGNhc2UgR2FtZVN0YXR1cy5MT1NUOlxuICAgICAgICByZXR1cm4gPGJ1dHRvbiBvbkNsaWNrPXtyZXNldEdhbWV9PlBsYXkgQWdhaW48L2J1dHRvbj47XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY29uc29sZS5sb2coXCJkZWZhdWx0XCIpO1xuICAgICAgICAgIHJldHVybiA8YnV0dG9uIG9uQ2xpY2s9e3Jlc2V0R2FtZX0+UGxheSBBZ2FpbjwvYnV0dG9uPjs7XG4gICAgfVxuICB9O1xuICByZXR1cm4gKFxuICAgIC8vIFJlYWN0LkZyYWdtZW50IDw+XG4gICAgPD5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwibWVzc2FnZVwiPntNZXNzYWdlc1tnYW1lU3RhdHVzXX08L2Rpdj5cbnsgICAgICAvKlxuICAgICAgICBIZXIgYnJ1Z2VyIGplZyBlbiBmdW5rdGlvbiB0aWwgYXQgdWRyZWduZSBpbmRob2xkZXQgYWYga25hcHBlbi5cbiAgICAgICAqL31cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYnV0dG9uXCI+e2J1dHRvbkFyZWFDb250ZW50KCl9PC9kaXY+XG4gICAgPC8+XG4gICk7XG59O1xuICBpbnRlcmZhY2UgR2FtZVNlc3Npb25Qcm9wc3tcbiAgICBjZWxsSWRzOkFycmF5PG51bWJlcj4sXG4gICAgY2hhbGxlbmdlQ2VsbElkczpBcnJheTxudW1iZXI+LFxuICAgIGNlbGxXaWR0aDpudW1iZXIsXG4gICAgY2hhbGxlbmdlU2l6ZTpudW1iZXIsXG4gICAgY2hhbGxlbmdlU2Vjb25kczpudW1iZXIsXG4gICAgcGxheVNlY29uZHM6bnVtYmVyLFxuICAgIG1heFdyb25nQXR0ZW1wdHM6bnVtYmVyLFxuICAgIGF1dG9TdGFydDpib29sZWFuLFxuICAgIHJlc2V0R2FtZTooZXZlbnQ6IFJlYWN0Lk1vdXNlRXZlbnQ8SFRNTEJ1dHRvbkVsZW1lbnQ+KSA9PiB2b2lkXG4gIH1cbmNvbnN0IEdhbWVTZXNzaW9uID0gKHtcbiAgY2VsbElkcyxcbiAgY2hhbGxlbmdlQ2VsbElkcyxcbiAgY2VsbFdpZHRoLFxuICBjaGFsbGVuZ2VTaXplLFxuICBjaGFsbGVuZ2VTZWNvbmRzLFxuICBwbGF5U2Vjb25kcyxcbiAgbWF4V3JvbmdBdHRlbXB0cyxcbiAgYXV0b1N0YXJ0LFxuICByZXNldEdhbWUsXG59OkdhbWVTZXNzaW9uUHJvcHMpID0+IHtcbiAgLy8gdXNlU3RhdGUoR2FtZVN0YXR1cy5QTEFZSU5HKTtcbiAgLy8gdXNlU3RhdGUoR2FtZVN0YXR1cy5XT04pO1xuICAvLyB1c2VTdGF0ZShHYW1lU3RhdHVzLkxPU1QpO1xuICBjb25zdCBbZ2FtZVN0YXR1cywgc2V0R2FtZVN0YXR1c10gPSB1c2VTdGF0ZShcbiAgICBhdXRvU3RhcnQgPyBHYW1lU3RhdHVzLkNIQUxMRU5HRSA6IEdhbWVTdGF0dXMuTkVXXG4gICk7XG4gIC8vIHBpY2tlZENlbGxJZHMgaG9sZGVyIHN0eXIgcMOlIGh2aWxrZSBjZWxsZXIgc29tIGJydWdlcmVuIGhhciB2YWxndFxuICAvLyB1c2VTdGF0ZShbMCwgMSwgMiwgMjIsIDIzLCAyNF0pO1xuICBjb25zdCB0bXBQaWNrZWRDZWxsSWRzOkFycmF5PG51bWJlcj49W107XG4gIGNvbnN0IFtwaWNrZWRDZWxsSWRzLCBzZXRQaWNrZWRDZWxsSWRzXSA9IHVzZVN0YXRlKHRtcFBpY2tlZENlbGxJZHMpO1xuICAvLyBjb3VudGRvd24gaG9sZGVyIHN0eXIgcMOlIGh2b3IgbWFuZ2Ugc2VrdW5kZXIgYnJ1Z2VyZW4gaGFyIHRpbGJhZ2UgLSBzdGFydGVyIG1lZCBwbGF5U2Vjb25kcyBwcm9wXG4gIGNvbnN0IFtjb3VudGRvd24sIHNldENvdW50ZG93bl0gPSB1c2VTdGF0ZShwbGF5U2Vjb25kcyk7XG4gIFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIEJydWdlcmVuIGhhciBzdGFydGV0IHNwaWxsZXQsIG9nIGthbiBpIHRyZSBzZWt1bmRlciBzZSBodm9yIGRlIGZhcnZlZGUgY2VsbGVyIGVyIHBsYWNlcmV0XG4gICAgbGV0IHRpbWVySWQ6YW55O1xuICAgIGlmIChnYW1lU3RhdHVzID09PSBHYW1lU3RhdHVzLkNIQUxMRU5HRSkge1xuICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQoXG4gICAgICAgICgpID0+IHNldEdhbWVTdGF0dXMoR2FtZVN0YXR1cy5QTEFZSU5HKSxcbiAgICAgICAgMTAwMCAqIGNoYWxsZW5nZVNlY29uZHNcbiAgICAgICk7XG4gICAgfVxuICAgIC8vIFNwaWxsZXQgZXIgaSBnYW5nLCBvZyBicnVnZXJlbiBoYXIgMTAgc2VrdW5kZXIgdGlsIGF0IG1hcmtlcmUgZGUgcmlndGlnZSBjZWxsZXJcbiAgICBpZiAoZ2FtZVN0YXR1cyA9PT0gR2FtZVN0YXR1cy5QTEFZSU5HKSB7XG4gICAgICB0aW1lcklkID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICBzZXRDb3VudGRvd24oY291bnRkb3duID0+IHtcbiAgICAgICAgICBpZiAoY291bnRkb3duID09PSAxKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgICAgICAgICBzZXRHYW1lU3RhdHVzKEdhbWVTdGF0dXMuTE9TVCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjb3VudGRvd24gLSAxO1xuICAgICAgICB9KTtcbiAgICAgIH0sIDEwMDApO1xuICAgIH1cbiAgICBpZiAoZ2FtZVN0YXR1cyA9PT0gR2FtZVN0YXR1cy5MT1NUKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIktsYXIgdGlsIG7DpnN0ZSBzcGlsIVwiKTtcbiAgICAgIC8vIHNldEdhbWVTdGF0dXMoR2FtZVN0YXR1cy5DSEFMTEVOR0UpO1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4gY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICB9LCBbY2hhbGxlbmdlU2Vjb25kcywgZ2FtZVN0YXR1c10pOyAgXG4gIFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IFtjb3JyZWN0UGlja3MsIHdyb25nUGlja3NdID0gdXRpbHMuYXJyYXlDcm9zc0NvdW50cyhcbiAgICAgIHBpY2tlZENlbGxJZHMsXG4gICAgICBjaGFsbGVuZ2VDZWxsSWRzXG4gICAgKTtcbiAgICBpZiAoY29ycmVjdFBpY2tzID09PSBjaGFsbGVuZ2VTaXplKSB7XG4gICAgICBzZXRHYW1lU3RhdHVzKEdhbWVTdGF0dXMuV09OKTtcbiAgICB9XG4gICAgaWYgKHdyb25nUGlja3MgPT09IG1heFdyb25nQXR0ZW1wdHMpIHtcbiAgICAgIHNldEdhbWVTdGF0dXMoR2FtZVN0YXR1cy5MT1NUKTtcbiAgICB9XG4gIH0sIFtjaGFsbGVuZ2VDZWxsSWRzLCBjaGFsbGVuZ2VTaXplLCBtYXhXcm9uZ0F0dGVtcHRzLCBwaWNrZWRDZWxsSWRzXSk7XG4gIC8qXG4gICAgLSBBbGxlIHZhcmlhYmxlciBicnVndCBpIHVzZUVmZmVjdCgpIGLDuHIgaW5rbHVkZXJlcyBpIG92ZW5zdMOlZW5kZSBhcnJheSwgc29tIGhvbGRlciDDuGplIG1lZCwgXG4gICAgaHZvcm7DpXIgdXNlRWZmZWN0IHNrYWwgb3BkYXRlcmVzLiBcbiAgICAtIGpzbGludCBob2xkZXIgw7hqZSBtZWQsIG9tIGFsbGUgcmVsZXZhbnRlIHZhcmlhYmxlciBlciBtZWQuXG4gICovXG4gIGNvbnN0IHBpY2tDZWxsID0gKGNlbGxJZDpudW1iZXIpID0+IHtcbiAgICBpZiAoZ2FtZVN0YXR1cyA9PT0gR2FtZVN0YXR1cy5QTEFZSU5HKSB7XG4gICAgICBzZXRQaWNrZWRDZWxsSWRzKChwaWNrZWRDZWxsSWRzKSA9PiB7XG4gICAgICAgIGlmIChwaWNrZWRDZWxsSWRzLmluY2x1ZGVzKGNlbGxJZCkpIHtcbiAgICAgICAgICByZXR1cm4gcGlja2VkQ2VsbElkcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gWy4uLnBpY2tlZENlbGxJZHMsIGNlbGxJZF07XG4gICAgICB9KTtcbiAgICB9XG4gIH07ICBcbiAgXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJnYW1lXCI+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImdyaWRcIj5cbiAgICAgICAge2NlbGxJZHMubWFwKGNlbGxJZCA9PiAoXG4gICAgICAgICAgPENlbGxcbiAgICAgICAgICAgIC8vIHVuaWt0IElEIHRpbCBodmVyIGNlbGxlXG4gICAgICAgICAgICBrZXkgICAgICAgICAgID0geyBjZWxsSWQgfVxuICAgICAgICAgICAgLy8gQnJlZGRlIHNvbSBhZmjDpm5nZXIgYWYgYW50YWwgY2VsbGVyIGkgaHZlciByw6Zra2VcbiAgICAgICAgICAgIHdpZHRoICAgICAgICAgPSB7IGNlbGxXaWR0aCB9XG4gICAgICAgICAgICAvLyBTdGF0dXMgcMOlIHNwaWxsZXQgXG4gICAgICAgICAgICBnYW1lU3RhdHVzICAgID0geyBnYW1lU3RhdHVzIH1cbiAgICAgICAgICAgIC8vIEVyIGRldCBlbiBjaGFsbGVuZ2UgY2VsbD8gIC0gYnJ1Z2VyIEFycmF5LmluY2x1ZGVzXG4gICAgICAgICAgICBpc0NoYWxsZW5nZSAgID0geyBjaGFsbGVuZ2VDZWxsSWRzLmluY2x1ZGVzKGNlbGxJZCkgfVxuICAgICAgICAgICAgLy8gZXIgY2VsbGVuIHZhbGd0PyAgICAgICAgICAgLSBicnVnZXIgQXJyYXkuaW5jbHVkZXNcbiAgICAgICAgICAgIGlzUGlja2VkICAgICAgPSB7IHBpY2tlZENlbGxJZHMuaW5jbHVkZXMoY2VsbElkKSB9XG4gICAgICAgICAgICAvLyBOZWRhcnZlciBmdW5rdGlvbiBzb20gdGpla2tlciBvbSBjZWxsZW4gYWxsZXJlZGUgZXIgdmFsZ3QgLSBlbGxlcnMgaW5rbHVkZXJlcyBkZW4gaSB2YWxndGUgY2VsbGVyIChwaWNrZWRDZWxsSWRzKVxuICAgICAgICAgICAgb25DbGljayAgICAgICA9IHsgKCkgPT4gcGlja0NlbGwoY2VsbElkKSB9XG4gICAgICAgICAgICAvPlxuICAgICAgICApKX1cbiAgICAgIDwvZGl2PlxuICAgICAgPEZvb3RlclxuICAgICAgICBnYW1lU3RhdHVzICAgICAgICA9IHsgZ2FtZVN0YXR1cyB9XG4gICAgICAgIGNvdW50ZG93biAgICAgICAgID0geyBjb3VudGRvd24gfVxuICAgICAgICBzdGFydEdhbWUgICAgICAgICA9IHsgKCkgPT4gc2V0R2FtZVN0YXR1cyhHYW1lU3RhdHVzLkNIQUxMRU5HRSkgfVxuICAgICAgICByZXNldEdhbWUgICAgICAgICA9IHsgcmVzZXRHYW1lIH1cbiAgICAgIC8+XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBHYW1lR2VuZXJhdG9yKCkge1xuICAvLyBQbGFjZXIgYWx0aWQgc3RhdGUtZWxlbWVudHMgZsO4cnN0IVxuICBjb25zdCBbZ2FtZUlkLCBzZXRHYW1lSWRdICAgPSB1c2VTdGF0ZSgxKTtcblxuICBjb25zdCBncmlkU2l6ZSAgICAgICAgICAgICAgPSA1O1xuICBjb25zdCBjaGFsbGVuZ2VTaXplICAgICAgICAgPSA2O1xuICAvLyBSZXR1cm5lcmVyIGVuIGFycmF5IG1lZCB4LWFudGFsIGVsZW10ZXIgMSwyLDMuLi5cbiAgLy8gRml4ZWQgQXJyYXkgZm9yIGh2ZXIgZW5rZWx0IHNwaWwgKHNrYWwgZGVyZm9yIGlra2UgdsOmcmUgaSBzdGF0ZSlcbiAgY29uc3QgY2VsbElkcyAgICAgICAgICAgICAgID0gdXRpbHMuY3JlYXRlQXJyYXkoZ3JpZFNpemUgKiBncmlkU2l6ZSk7XG4gIGNvbnN0IGNlbGxXaWR0aCAgICAgICAgICAgICA9IDEwMCAvIGdyaWRTaXplO1xuICAvKlxuICAgIFJldHVybmVyZXIgZW4gYXJyYXkgbWVkIHRpbGbDpmxkaWdlIHRhbFxuICAgIC0gY2VsbElkcyBlciBlbiBhcnJheSBtZWQgZGUgYWt0dWVsbGUgZmVsdGVyXG4gICAgLSBjaGFsbGVuZ2VTaXplIGJlc3RlbW1lciBodm9yIG1hbmdlIGZhcnZlciwgYnJ1Z2VyZW4gc2thbCBmaW5kZVxuICAqL1xuICBjb25zdCBjaGFsbGVuZ2VDZWxsSWRzID0gdXRpbHMuc2FtcGxlQXJyYXkoY2VsbElkcywgY2hhbGxlbmdlU2l6ZSk7XG4gIFxuICBcbiAgcmV0dXJuIChcbiAgICA8R2FtZVNlc3Npb25cbiAgICAgIGtleSAgICAgICAgICAgICAgID0geyBnYW1lSWQgfVxuXG4gICAgICBjaGFsbGVuZ2VTaXplICAgICA9IHsgY2hhbGxlbmdlU2l6ZSB9XG4gICAgICBjZWxsSWRzICAgICAgICAgICA9IHsgY2VsbElkcyB9XG4gICAgICBjZWxsV2lkdGggICAgICAgICA9IHsgY2VsbFdpZHRoIH1cbiAgICAgIFxuICAgICAgY2hhbGxlbmdlQ2VsbElkcyAgPSB7IGNoYWxsZW5nZUNlbGxJZHMgfVxuXG4gICAgICBjaGFsbGVuZ2VTZWNvbmRzICA9IHsgMyB9XG4gICAgICBwbGF5U2Vjb25kcyAgICAgICA9IHsgMTAgfVxuICAgICAgbWF4V3JvbmdBdHRlbXB0cyAgPSB7IDMgfVxuXG4gICAgICBhdXRvU3RhcnQgICAgICAgICA9IHsgZ2FtZUlkID4gMSB9XG5cbiAgICAgIHJlc2V0R2FtZSAgICAgICAgID0geygpID0+IHNldEdhbWVJZChnYW1lSWQgPT4gZ2FtZUlkICsgMSl9XG4gICAgLz5cbiAgKTtcbn07XG5cbi8vIE1hdGggc2NpZW5jZVxuY29uc3QgdXRpbHMgPSB7XG4gIC8qIENyZWF0ZSBhbiBhcnJheSBiYXNlZCBvbiBhIG51bWVyaWMgc2l6ZSBwcm9wZXJ0eS5cbiAgICAgRXhhbXBsZTogY3JlYXRlQXJyYXkoNSkgPT4gWzAsIDEsIDIsIDMsIDRdICovXG4gIGNyZWF0ZUFycmF5OiAoc2l6ZTpudW1iZXIpID0+IEFycmF5LmZyb20oeyBsZW5ndGg6IHNpemUgfSwgKF8sIGkpID0+IGkpLFxuXG4gIC8qIFBpY2sgcmFuZG9tIGVsZW1lbnRzIGZyb20gb3JpZ0FycmF5IHVwIHRvIHNhbXBsZVNpemVcbiAgICAgQW5kIHVzZSB0aGVtIHRvIGZvcm0gYSBuZXcgYXJyYXkuXG4gICAgIEV4YW1wbGU6IHNhbXBsZUFycmF5KFs5LCAxMiwgNCwgNywgNV0sIDMpID0+IFsxMiwgNywgNV0gKi9cbiAgc2FtcGxlQXJyYXk6IChvcmlnQXJyYXk6QXJyYXk8bnVtYmVyPiwgc2FtcGxlU2l6ZTpudW1iZXIpID0+IHtcbiAgICBjb25zdCBjb3B5ID0gb3JpZ0FycmF5LnNsaWNlKDApO1xuICAgIGNvbnN0IHNhbXBsZSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2FtcGxlU2l6ZSAmJiBpIDwgY29weS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjb3B5Lmxlbmd0aCk7XG4gICAgICBzYW1wbGUucHVzaChjb3B5LnNwbGljZShpbmRleCwgMSlbMF0pO1xuICAgIH1cbiAgICByZXR1cm4gc2FtcGxlO1xuICB9LFxuXG4gIC8qIEdpdmVuIGEgc3JjQXJyYXkgYW5kIGEgY3Jvc3NBcnJheSwgY291bnQgaG93IG1hbnkgZWxlbWVudHMgXG4gICAgIGluIHNyY0FycmF5IGV4aXN0IG9yIGRvIG5vdCBleGlzdCBpbiBjcm9zc0FycmF5LlxuICAgICBSZXR1cm5zIGFuIGFycmF5IGxpa2UgW2luY2x1ZGVDb3VudCwgZXhjbHVkZUNvdW50XVxuICAgICBFeGFtcGxlOiBhcnJheUNyb3NzQ291bnRzKFswLCAxLCAyLCAzLCA0XSwgWzEsIDMsIDVdKSA9PiBbMiwgM10gKi9cbiAgYXJyYXlDcm9zc0NvdW50czogKHNyY0FycmF5OkFycmF5PG51bWJlcj4sIGNyb3NzQXJyYXk6QXJyYXk8bnVtYmVyPikgPT4ge1xuICAgIGxldCBpbmNsdWRlQ291bnQgPSAwO1xuICAgIGxldCBleGNsdWRlQ291bnQgPSAwO1xuICAgIHNyY0xvb3A6IGZvciAobGV0IHMgPSAwOyBzIDwgc3JjQXJyYXkubGVuZ3RoOyBzKyspIHtcbiAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgY3Jvc3NBcnJheS5sZW5ndGg7IGMrKykge1xuICAgICAgICBpZiAoY3Jvc3NBcnJheVtjXSA9PT0gc3JjQXJyYXlbc10pIHtcbiAgICAgICAgICBpbmNsdWRlQ291bnQgKz0gMTtcbiAgICAgICAgICBjb250aW51ZSBzcmNMb29wO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBleGNsdWRlQ291bnQgKz0gMTtcbiAgICB9XG4gICAgcmV0dXJuIFtpbmNsdWRlQ291bnQsIGV4Y2x1ZGVDb3VudF07XG4gIH0sXG59O1xuXG4vLyBSZWFjdERPTS5yZW5kZXIoXG4vLyAgIDxHYW1lR2VuZXJhdG9yIC8+LFxuLy8gICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncm9vdCcpXG4vLyApOyJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsIkdhbWVTdGF0dXMiLCJORVciLCJDSEFMTEVOR0UiLCJQTEFZSU5HIiwiV09OIiwiTE9TVCIsIkNlbGxTdGF0dXMiLCJOT1JNQUwiLCJISUdITElHSFQiLCJDT1JSRUNUIiwiV1JPTkciLCJNZXNzYWdlcyIsIkNlbGwiLCJ3aWR0aCIsImdhbWVTdGF0dXMiLCJpc0NoYWxsZW5nZSIsImlzUGlja2VkIiwib25DbGljayIsImNlbGxTdGF0dXMiLCJiYWNrZ3JvdW5kQ29sb3IiLCJGb290ZXIiLCJjb3VudGRvd24iLCJzdGFydEdhbWUiLCJyZXNldEdhbWUiLCJidXR0b25BcmVhQ29udGVudCIsImNvbnNvbGUiLCJsb2ciLCJHYW1lU2Vzc2lvbiIsImNlbGxJZHMiLCJjaGFsbGVuZ2VDZWxsSWRzIiwiY2VsbFdpZHRoIiwiY2hhbGxlbmdlU2l6ZSIsImNoYWxsZW5nZVNlY29uZHMiLCJwbGF5U2Vjb25kcyIsIm1heFdyb25nQXR0ZW1wdHMiLCJhdXRvU3RhcnQiLCJzZXRHYW1lU3RhdHVzIiwidG1wUGlja2VkQ2VsbElkcyIsInBpY2tlZENlbGxJZHMiLCJzZXRQaWNrZWRDZWxsSWRzIiwic2V0Q291bnRkb3duIiwidGltZXJJZCIsInNldFRpbWVvdXQiLCJzZXRJbnRlcnZhbCIsImNsZWFyVGltZW91dCIsInV0aWxzIiwiYXJyYXlDcm9zc0NvdW50cyIsImNvcnJlY3RQaWNrcyIsIndyb25nUGlja3MiLCJwaWNrQ2VsbCIsImNlbGxJZCIsImluY2x1ZGVzIiwibWFwIiwiR2FtZUdlbmVyYXRvciIsImdhbWVJZCIsInNldEdhbWVJZCIsImdyaWRTaXplIiwiY3JlYXRlQXJyYXkiLCJzYW1wbGVBcnJheSIsInNpemUiLCJBcnJheSIsImZyb20iLCJsZW5ndGgiLCJfIiwiaSIsIm9yaWdBcnJheSIsInNhbXBsZVNpemUiLCJjb3B5Iiwic2xpY2UiLCJzYW1wbGUiLCJpbmRleCIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSIsInB1c2giLCJzcGxpY2UiLCJzcmNBcnJheSIsImNyb3NzQXJyYXkiLCJpbmNsdWRlQ291bnQiLCJleGNsdWRlQ291bnQiLCJzcmNMb29wIiwicyIsImMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./pages/cases/memory/index.tsx\n");

/***/ })

});